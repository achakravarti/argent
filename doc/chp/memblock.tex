%
% document colours
%
\definecolor{pastelblue}{RGB}{68,78,81}
\definecolor{green}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{purple}{rgb}{0.58,0,0.82}
\definecolor{silver}{rgb}{0.75,0.75,0.75}


%
% code declaration list style
%
\lstdefinestyle{declaration}{
  backgroundcolor=\color{white},
  basicstyle=\ttfamily\scriptsize,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{green},
  frame=none,
  keywordstyle=\color{blue},
  language=C,
  numberstyle=\tiny\color{green},
  postbreak=\mbox{\textcolor{green}{$\hookrightarrow$}\space},
  showspaces=false,
  showstringspaces=false,
  stringstyle=\color{orange},
  tabsize=4,
}


%
% code definition list style
%
\lstdefinestyle{definition}{
  backgroundcolor=\color{silver},
  basicstyle=\ttfamily\scriptsize,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{green},
  frame=single,
  keywordstyle=\color{blue},
  language=C,
  numberstyle=\tiny\color{green},
  postbreak=\mbox{\textcolor{green}{$\hookrightarrow$}\space},
  showspaces=false,
  showstringspaces=false,
  stringstyle=\color{orange},
  tabsize=4,
}

%
% command aliases for ag_memblock_t interface functions
%
\newcommand{\agMemblockNew}{\texttt{ag\_memblock\_new()}}
\newcommand{\agMemblockCopy}{\texttt{ag\_memblock\_copy()}}
\newcommand{\agMemblockSz}{\texttt{ag\_memblock\_sz()}}
\newcommand{\agMemblockResize}{\texttt{ag\_memblock\_resize()}}
\newcommand{\agMemblockFree}{\texttt{ag\_memblock\_free()}}


%
% command to show function synopsis
%
\newcommand{\agFnSynopsis}[3]{
  \begin{wrapfigure}{l}{0.6\textwidth}
  \begin{minipage}{0.6\textwidth}
  \vspace{-1em}
  \begin{noteblock}
  \small
  #1.
  \lstset{style=declaration}
  \lstinputlisting[linerange={#2}]{../src/api.h}
  #3.
  \end{noteblock}
  \end{minipage}
  \end{wrapfigure}
}


%
% command to show show algorithm
%
\newcommand{\agAlgorithm}[3]{
  \begin{wrapfigure}{r}{.6\textwidth}
  \begin{minipage}{0.6\textwidth}
  \vspace{-1em}
  \begin{algorithm}[H]
  \small
  \caption{#2}
  \label{#1}
  \begin{algorithmic}
  #3
  \end{algorithmic}
  \end{algorithm}
  \end{minipage}
  \end{wrapfigure}
}


\chapter{Memory Block Module}
\ThisULCornerWallPaper{0.5}{kirsty-paget.jpg}
\newpage


%
% section ag_memblock_new()
%
\section{Function \agMemblockNew}
\agFnSynopsis{\agMemblockNew---allocates block of heap memory; returns allocated
  block of heap memory}{265-265}{\texttt{sz} = size in bytes to allocate}
\kant[1]
\agAlgorithm{alg:agMemblockNew}{\agMemblockNew}{
  \Require $sz \geq 0$
  \Procedure{ag\_memblock\_new}{$sz$}
  \State $bfr \gets malloc(sz)$
  \State $bfr \gets memset(0)$
  \State return $bfr$
  \EndProcedure
  \Ensure $bfr \neq null$
}
\kant[2]


%
% section ag_memblock_copy()
%
\section{Function \agMemblockCopy}
\agFnSynopsis{\agMemblockCopy---copies existing block of heap memory; returns
copied block of heap memory}{274-274}{\texttt{bfr} = heap block to copy}
\kant[1]
\agAlgorithm{alg:agMemblockCopy}{\agMemblockCopy}{
  \Require $bfr \neq null$
  \Procedure{ag\_memblock\_copy}{$bfr$}
  \State $sz \gets ag\_memblock\_sz(bfr)$ \Comment{compute size of bfr}
  \State $cp \gets ag\_memblock\_new(sz)$ \Comment{create new block of size sz}
  \State $cp \gets memcpy(bfr)$ \Comment{copy bfr to cp}
  \State return $cp$
  \EndProcedure
}
\kant[2]
